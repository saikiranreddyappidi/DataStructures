
Chukkapalli Ramya
27 Feb 2023, 19:55
to me

ACC WEEK=3
1)Swap the contents and indexes in an array.
#include<stdio.h>

int main()
{
 int n;
 int a[20],res[20];
 scanf("%d",&n);
 for(int i=0;i<n;i++)
 {
  scanf("%d",&a[i]);
 }
 for(int i=0;i<n;i++)
 {
  res [a[i]]=i;
 }
 for(int i=0;i<n;i++)
 {
  printf("%d ",res[i]);
 }
 return 0;
}
2)Program to Print the Trapezium Pattern
#include <stdio.h>

int main(){
 int n,i,j,k=1,l,r,h=0;
 scanf("%d",&n);
 r=n*n+1;
 for(i=0;i<n;i++){
  l=0;
  for(j=0;j<(h-1);j++){
   printf(" ");
  }
  h+=3;
  for(j=0;j<(n-i);j++){
   l++;
   if(k<10){
    printf("0");
   }
   printf("%d ",k);
   k++;
  }
  for(j=0;j<(n-i);j++){
   printf("%d ",r);
   r++;
  }
  r=r-(n-i-1)*2-1;
  printf("\n ");
 }
}
3)Save memory with time to integer
#include <stdio.h>

#define VALID_MONTHS 12
#define VALID_DAYS 31
#define VALID_HOURS 24
#define VALID_MINUTES 60
#define VALID_SECONDS 60

int num_digits(int n) {
    int count = 0;
    while (n > 0) {
        count++;
        n /= 10;
    }
    return count;
}

int nth_digit(int n, int num) {
    int divisor = 1;
    for (int i = 0; i < n; i++) {
        divisor *= 10;
    }
    return (num / divisor) % 10;
}

unsigned int convert_datetime_to_int(int month, int day, int hour, int minute, int second) {
    unsigned int result = 0;
    result |= second % 10; 
    result |= ((second / 10) % 7) << 4; 
    result |= minute % 10 << 7; 
    result |= ((minute / 10) % 7) << 11; 
    result |= hour % 10 << 14; 
    result |= ((hour / 10) % 3) << 18; 
    result |= day % 10 << 20; 
    result |= ((day / 10) % 4) << 24; 
    result |= month % 10 << 26; 
    result |= ((month / 10) % 2) << 30; 
    return result;
}

int is_valid_date(int month, int day, int hour, int minute, int second) {
    if (month < 1 || month > VALID_MONTHS) {
        return 0;
    }
    if (day < 1 || day > VALID_DAYS) {
        return 0;
    }
    if (hour < 0 || hour >= VALID_HOURS) {
        return 0;
    }
    if (minute < 0 || minute >= VALID_MINUTES) {
        return 0;
    }
    if (second < 0 || second >= VALID_SECONDS) {
        return 0;
    }
    return 1;
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        int month, day, hour, minute, second;
        scanf("%d/%d %d:%d:%d", &month, &day, &hour, &minute, &second);
        if (is_valid_date(month, day, hour, minute, second)) {
            printf("%u\n", convert_datetime_to_int(month, day, hour, minute, second));
        } else {
            printf("INVALID\n");
        }
    }
    return 0;
}
4)Decompressing a string
#include <stdio.h>

int main() {
    char input[1000];
    fgets(input, 1000, stdin);

    int i = 0;
    while(input[i] != '\0') {
        char c = input[i];
        int count = 0;
        while(input[i+1] >= '0' && input[i+1] <= '9') {
            count = count * 10 + (input[i+1] - '0');
            i++;
        }
        for(int j = 0; j < count; j++) {
            printf("%c", c);
        }
        i++;
    }

    return 0;
}
5)Amicable number
#include<stdio.h>
int main()
{
 int num1,num2;
 scanf("%d",&num1);
 scanf("%d",&num2);
 int sum1=0,sum2=0;
 for(int i=1;i<num1;i++)
 {
  if(num1%i==0)
  {
   sum1=sum1+i;
  }
 }
 for(int i=1;i<num2;i++)
 {
  if(num2%i==0)
  {
   sum2=sum2+i;
  }
 }
 if(sum1==num2 && sum2==num1)
 printf("Amicable");
 else
 printf("Not Amicable");
 return 0;
}
6)Bomb Diffusion.
#include <stdio.h>

int main() {
    int size, key;
    scanf("%d %d", &size, &key);

    int message[size];
    for(int i = 0; i < size; i++) {
        scanf("%d", &message[i]);
    }

    int sequence[size];
    for(int i = 0; i < size; i++) {
        int sum = 0;
        if(key > 0) {
            for(int j = 1; j <= key; j++) {
                sum += message[(i+j)%size];
            }
        }
        else {
            for(int j = -1; j >= key; j--) {
                sum += message[(i+j+size)%size];
            }
        }
        sequence[i] = sum;
    }

    for(int i = 0; i < size; i++) {
        printf("%d ", sequence[i]);
    }

    return 0;
}
7)Right rotate the given number for N times.
#include <stdio.h>

int main() {
    int N, num;
    scanf("%d %d", &N, &num);

    int temp = num;
    int digits = 0;
    while(temp > 0) {
        digits++;
        temp /= 10;
    }

    for(int i = 1; i <= N; i++) {
        int last_digit = num % 10;
        num /= 10;
        num += last_digit * (1 * (int)pow(10, digits-1));
    }

    printf("%d", num);

    return 0;
}
8)Largest Sum Contiguous Subarray.
#include <stdio.h>

int main() {
    int n;
    scanf("%d", &n);

    int arr[n];
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    int max_so_far = arr[0];
    int max_ending_here = arr[0];

    for (int i = 1; i < n; i++) {
        max_ending_here = (max_ending_here + arr[i] > arr[i]) ? max_ending_here + arr[i] : arr[i];
        max_so_far = (max_so_far > max_ending_here) ? max_so_far : max_ending_here;
    }

    printf("%d\n", max_so_far);

    return 0;
}
11)Find Excel column name from a given column number
#include <stdio.h>
static char *convert_To_Excel_Title(int column_no)
{
    if (column_no <= 0) {
        return "";
    }

    char *result = malloc(1024);
    int len = 0;
    do {
        result[len++] = ((column_no - 1) % 26) + 'A';
        column_no = (column_no - 1) / 26;
    } while (column_no > 0);
    result[len] = '\0';

    int i, j;
    for (i = 0, j = len - 1; i < j; i++, j--) {
        char c = result[i];
        result[i] = result[j];
        result[j] = c;
    }
    return result;
}

int main(void)
{
    int n;
 scanf("%d",&n);
    printf("\n %s ",convert_To_Excel_Title(n));
   
    return 0;
}
12)Longest Palindromic Substring.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static inline int min(int x, int y)
 {
     return x < y ? x : y;
 }
static int find_longest_substring(char *s, char output[])
{
    int i, j;
    char s2[3000] = { '\0' };

    s2[0] = '$';
    for (i = 0; s[i] != '\0'; i++) {
        s2[(i<<1)+1] = '#';
        s2[(i<<1)+2] = s[i];
    }
    s2[(i<<1)+1] = '#';
    int len = (i<<1)+2;
    s2[len] = '\0';
    
    int p[3000] = { 0 }; 
    int id = 0;  
    int limit = 0;  
    int max_len = 0;  
    int max_id = 0;  
    for (i = 1; i < len; i++) {
        if (i < limit) {
            p[i] = min(p[2*id-i], limit-i);
        } else {
            p[i] = 1;
        }
        
        while (s2[i+p[i]] == s2[i-p[i]]) {
            p[i]++;
        }
        
        if (i+p[i] > limit) {
            limit = i+p[i];
            id = i;
        }
        if (max_len < p[i]-1) {
            max_len = p[i]-1;
            max_id = i;
        }
    }
    
    for (j = 0, i = max_id - max_len; i <= max_id+max_len; i++) {
        if (s2[i] != '#') {
            output[j++] = s2[i];
        }
    }
    return max_len;
}

static char *longest_Palindrom(char *s)
{
    int i;
    if (s == NULL) {
        return NULL;
    }

    int len = strlen(s);
    if (len <= 1) {
        return s;
    }

    char *palindrome_str = malloc(2000);
    memset(palindrome_str, 0, sizeof(palindrome_str));

    int size = find_longest_substring(s, palindrome_str);
    palindrome_str[size] = '\0';
    return palindrome_str;
}

int main(void)
 {
    char *str1[20];
 scanf("%s",str1);
 printf("%s\n", longest_Palindrom(str1));
 return 0;
 }
15)Balanced parentheses.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LEN 1000


struct Stack {
    char data[MAX_LEN];
    int top;
};


void push(struct Stack *s, char c) {
    s->top++;
    s->data[s->top] = c;
}


char pop(struct Stack *s) {
    char c = s->data[s->top];
    s->top--;
    return c;
}


int balanced_parentheses(char *str) {
    int len = strlen(str);
    struct Stack s;
    s.top = -1;
    int count = 0;

    for (int i = 0; i < len; i++) {
        if (str[i] == '(') {
            push(&s, str[i]);
        } else if (str[i] == ')') {
            if (s.top == -1 || pop(&s) != '(') {
                return -1; 
            } else {
                count++; 
            }
        }
    }

    if (s.top != -1) {
        return -1;
    } else {
        return count;
    }
}

int main() {
    char str[MAX_LEN];
    fgets(str, MAX_LEN, stdin);
    str[strcspn(str, "\n")] = 0; 

    int count = balanced_parentheses(str);

    if (count == -1) {
        printf("\n");
    } else {
        printf("%d\n", count);
    }

    return 0;
}
16)Check whether the given date is valid or not.
#include<stdio.h>

int main()
{
    int dd, mm, yy;

   
    scanf("%d/%d/%d", &dd, &mm, &yy);

    
    if (yy < 1900 || yy > 2099)
    {
        printf("Invalid");
        return 0;
    }

    
    if (mm < 1 || mm > 12)
    {
        printf("Invalid");
        return 0;
    }

    
    int max_day;
    if (mm == 2)
    {
        
        if (yy % 4 == 0 && (yy % 100 != 0 || yy % 400 == 0))
            max_day = 29;
        else
            max_day = 28;
    }
    else if (mm == 4 || mm == 6 || mm == 9 || mm == 11)
        max_day = 30;
    else
        max_day = 31;

    if (dd < 1 || dd > max_day)
    {
        printf("Invalid");
        return 0;
    }

    printf("Valid");
    return 0;
}
17)8 Cell Complete (WIPRO Specific)
#include <stdio.h>
void cellCompete(int* cells, int days) {
    int nextDay[8];
    for (int i = 0; i < days; i++) {
        // Consider the previous state of the cells
        for (int j = 0; j < 8; j++) {
            int left = (j == 0) ? 0 : cells[j - 1];
            int right = (j == 7) ? 0 : cells[j + 1];
            if (left == right) {
                nextDay[j] = 0;
            } else {
                nextDay[j] = 1;
            }
        }
        // Update the cells with the new state
        for (int j = 0; j < 8; j++) {
            cells[j] = nextDay[j];
        }
    }
}

int main() {
    int cells[8];
    int days;
    for (int i = 0; i < 8; i++) {
        scanf("%d", &cells[i]);
    }
    scanf("%d", &days);
    cellCompete(cells, days);
    for (int i = 0; i < 8; i++) {
        printf("%d ", cells[i]);
    }
    printf("\n");
    return 0;
}
19)Unlocking Key.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int compare(const void *a, const void *b) {
    return *(char*)a - *(char*)b;
}

int getUnlockingKey(int lockingKey) {
    char str[20];
    sprintf(str, "%d", lockingKey);
    int len = strlen(str);
    qsort(str, len, sizeof(char), compare);
    int i = 0;
    while (str[i] == '0') {
        i++;
    }
    char temp = str[0];
    str[0] = str[i];
    str[i] = temp;
    return atoi(str);
}

int main() {
    int lockingKey;
    
    scanf("%d", &lockingKey);
    int unlockingKey = getUnlockingKey(lockingKey);
    printf("%d\n", unlockingKey);
    return 0;
}
20)Count and say
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

char* countAndSay(int n) {
    if (n == 1) {
        return "1";
    }
    char* prev = countAndSay(n - 1);
    int len = strlen(prev);
    char* result = malloc(2 * len * sizeof(char));
    int index = 0, count = 1;
    for (int i = 1; i < len; i++) {
        if (prev[i] == prev[i - 1]) {
            count++;
        }
        else {
            result[index++] = count + '0';
            result[index++] = prev[i - 1];
            count = 1;
        }
    }
    result[index++] = count + '0';
    result[index++] = prev[len - 1];
    result[index] = '\0';
    return result;
}

int main() {
    int n;
   
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        printf("%s\n", countAndSay(i));
    }
    return 0;
}
